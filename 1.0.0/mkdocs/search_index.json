{
    "docs": [
        {
            "location": "/", 
            "text": "What's OpenVeo Plugin Generator ?\n\n\nOpenVeo Plugin Generator is a \nYeoman\n plugin generator for \nOpenVeo\n used to improve OpenVeo plugin development.\n\n\nPlugin\n\n\nThe generated plugin provides many features:\n\n\n\n\nMany Grunt tasks to manage (compile, minify, generate documention) your code - Ready to production\n\n\nAngular.js to manage back-end and front-end\n\n\nA Node.js server with Express.js ready to start\n\n\nNo JQuery dependency\n\n\nResponsive Design\n\n\nThe Sass preprocessor\n\n\nUse of Bootstrap inherited from OpenVeo Core\n\n\nUnit tests and e2e tests using \nProtractor\n\n\nAll the features of the OpenVeo Core are available in your plugin like i18n translation, alerts, CRUD controllers to manage your entities, a logger ...\n\n\nThe possibility to override all functions inherited from OpenVeo Core\n\n\nA full documentation to get into the OpenVeo solution\n\n\n\n\nStructure\n\n\nThere is the general structure of a plugin\n\n\n.\n\u251c\u2500\u2500 app\n\u2502   \u251c\u2500\u2500 client          \n\u2502   \u2502   \u2514\u2500\u2500 admin\n\u2502   \u2502       \u251c\u2500\u2500 compass\n\u2502   \u2502       \u2514\u2500\u2500 js \n\u2502   \u2502           \u2514\u2500\u2500 ovPluginName \n\u2502   \u2514\u2500\u2500 server\n\u2502       \u251c\u2500\u2500 controllers\n\u2502       \u251c\u2500\u2500 models\n\u2502       \u251c\u2500\u2500 providers\n\u2502       \u251c\u2500\u2500 Plugin.js\n\u2502       \u2514\u2500\u2500 httpErrors.js\n\u251c\u2500\u2500 assets\n\u2502   \u251c\u2500\u2500 be\n\u2502   \u2502   \u251c\u2500\u2500 css\n\u2502   \u2502   \u251c\u2500\u2500 js\n\u2502   \u2502   \u2514\u2500\u2500 views\n\u2502   \u2514\u2500\u2500 lib \n\u251c\u2500\u2500 build\n\u2502   \u2514\u2500\u2500 uglify\n\u2502       \u2514\u2500\u2500 ovPluginName    \n\u251c\u2500\u2500 docs\n\u251c\u2500\u2500 i18n\n\u251c\u2500\u2500 migrations\n\u251c\u2500\u2500 tasks\n\u251c\u2500\u2500 tests\n\u2502   \u251c\u2500\u2500 client\n\u2502   \u2514\u2500\u2500 server\n\u251c\u2500\u2500 .bowerrc\n\u251c\u2500\u2500 .eslintrc\n\u251c\u2500\u2500 .gitattributes\n\u251c\u2500\u2500 .npmignore\n\u251c\u2500\u2500 CHANGELOG.md\n\u251c\u2500\u2500 Gruntfile.js\n\u251c\u2500\u2500 README.md       \n\u251c\u2500\u2500 bower.json        \n\u251c\u2500\u2500 conf.js\n\u251c\u2500\u2500 index.js\n\u251c\u2500\u2500 install.js\n\u251c\u2500\u2500 mkdocs.yml\n\u2514\u2500\u2500 package.json", 
            "title": "INTRODUCTION"
        }, 
        {
            "location": "/#whats-openveo-plugin-generator", 
            "text": "OpenVeo Plugin Generator is a  Yeoman  plugin generator for  OpenVeo  used to improve OpenVeo plugin development.", 
            "title": "What's OpenVeo Plugin Generator ?"
        }, 
        {
            "location": "/#plugin", 
            "text": "The generated plugin provides many features:   Many Grunt tasks to manage (compile, minify, generate documention) your code - Ready to production  Angular.js to manage back-end and front-end  A Node.js server with Express.js ready to start  No JQuery dependency  Responsive Design  The Sass preprocessor  Use of Bootstrap inherited from OpenVeo Core  Unit tests and e2e tests using  Protractor  All the features of the OpenVeo Core are available in your plugin like i18n translation, alerts, CRUD controllers to manage your entities, a logger ...  The possibility to override all functions inherited from OpenVeo Core  A full documentation to get into the OpenVeo solution", 
            "title": "Plugin"
        }, 
        {
            "location": "/#structure", 
            "text": "There is the general structure of a plugin  .\n\u251c\u2500\u2500 app\n\u2502   \u251c\u2500\u2500 client          \n\u2502   \u2502   \u2514\u2500\u2500 admin\n\u2502   \u2502       \u251c\u2500\u2500 compass\n\u2502   \u2502       \u2514\u2500\u2500 js \n\u2502   \u2502           \u2514\u2500\u2500 ovPluginName \n\u2502   \u2514\u2500\u2500 server\n\u2502       \u251c\u2500\u2500 controllers\n\u2502       \u251c\u2500\u2500 models\n\u2502       \u251c\u2500\u2500 providers\n\u2502       \u251c\u2500\u2500 Plugin.js\n\u2502       \u2514\u2500\u2500 httpErrors.js\n\u251c\u2500\u2500 assets\n\u2502   \u251c\u2500\u2500 be\n\u2502   \u2502   \u251c\u2500\u2500 css\n\u2502   \u2502   \u251c\u2500\u2500 js\n\u2502   \u2502   \u2514\u2500\u2500 views\n\u2502   \u2514\u2500\u2500 lib \n\u251c\u2500\u2500 build\n\u2502   \u2514\u2500\u2500 uglify\n\u2502       \u2514\u2500\u2500 ovPluginName    \n\u251c\u2500\u2500 docs\n\u251c\u2500\u2500 i18n\n\u251c\u2500\u2500 migrations\n\u251c\u2500\u2500 tasks\n\u251c\u2500\u2500 tests\n\u2502   \u251c\u2500\u2500 client\n\u2502   \u2514\u2500\u2500 server\n\u251c\u2500\u2500 .bowerrc\n\u251c\u2500\u2500 .eslintrc\n\u251c\u2500\u2500 .gitattributes\n\u251c\u2500\u2500 .npmignore\n\u251c\u2500\u2500 CHANGELOG.md\n\u251c\u2500\u2500 Gruntfile.js\n\u251c\u2500\u2500 README.md       \n\u251c\u2500\u2500 bower.json        \n\u251c\u2500\u2500 conf.js\n\u251c\u2500\u2500 index.js\n\u251c\u2500\u2500 install.js\n\u251c\u2500\u2500 mkdocs.yml\n\u2514\u2500\u2500 package.json", 
            "title": "Structure"
        }, 
        {
            "location": "/developers/installation/", 
            "text": "Getting Started\n\n\nYou need to install Yeoman and OpenVeo Plugin Generator and then you can create your OpenVeo plugin:\n\n\nPrerequies\n\n\n# Install Yeoman and OpenVeo Plugin\nnpm install -g yo generator-openveo-plugin\n\n\n\nInstallation\n\n\n# You must run the generator from the Openveo core folder\n# Run openveo-plugin and follow the instructions\nyo openveo-plugin", 
            "title": "Installation"
        }, 
        {
            "location": "/developers/installation/#getting-started", 
            "text": "You need to install Yeoman and OpenVeo Plugin Generator and then you can create your OpenVeo plugin:", 
            "title": "Getting Started"
        }, 
        {
            "location": "/developers/installation/#prerequies", 
            "text": "# Install Yeoman and OpenVeo Plugin\nnpm install -g yo generator-openveo-plugin", 
            "title": "Prerequies"
        }, 
        {
            "location": "/developers/installation/#installation", 
            "text": "# You must run the generator from the Openveo core folder\n# Run openveo-plugin and follow the instructions\nyo openveo-plugin", 
            "title": "Installation"
        }, 
        {
            "location": "/developers/generators/", 
            "text": "Available generators\n\n\nOpenVeo plugins provide some generators:\n\n\n\n\nopenveo-plugin\n (default: openveo-plugin:app)\n\n\nopenveo-plugin:entity\n\n\n\n\nApp\n\n\nSets up a new Openveo plugin, generating all the boilerplate you need to get started.\n\n\nThis plugin provide many grunt tasks to generate and publish documentation, to minify and compile your code, to start tests ...\n\n\nAfter that, you can start you OpenVeo server and see your plugin in your menu with an access to a TODO page.\n\n\nEntity\n\n\nGenerates a new entity for the plugin with all files you need and the associated configuration (model, controller, provider)\n\n\nYo options\n\n\nyo openveo-plugin --help or yo openveo-plugin -h for help. If not provided, default values will be used.\n\n\n\n\n--skip-install\n do not run \nbower install\n and \nnpm install\n after generating the app, default is false (not skipping install)", 
            "title": "Generators"
        }, 
        {
            "location": "/developers/generators/#available-generators", 
            "text": "OpenVeo plugins provide some generators:   openveo-plugin  (default: openveo-plugin:app)  openveo-plugin:entity", 
            "title": "Available generators"
        }, 
        {
            "location": "/developers/generators/#app", 
            "text": "Sets up a new Openveo plugin, generating all the boilerplate you need to get started.  This plugin provide many grunt tasks to generate and publish documentation, to minify and compile your code, to start tests ...  After that, you can start you OpenVeo server and see your plugin in your menu with an access to a TODO page.", 
            "title": "App"
        }, 
        {
            "location": "/developers/generators/#entity", 
            "text": "Generates a new entity for the plugin with all files you need and the associated configuration (model, controller, provider)", 
            "title": "Entity"
        }, 
        {
            "location": "/developers/generators/#yo-options", 
            "text": "yo openveo-plugin --help or yo openveo-plugin -h for help. If not provided, default values will be used.   --skip-install  do not run  bower install  and  npm install  after generating the app, default is false (not skipping install)", 
            "title": "Yo options"
        }, 
        {
            "location": "/developers/conf/", 
            "text": "Introduction\n\n\nA consequent part of the development of openveo-core and plugins is made in \nconf.js\n file at project root. \nconf.js\n is used to :\n\n\n\n\nMap routes on actions\n\n\nCreate entities\n\n\nDefine back end permissions\n\n\nDefine back end menu items\n\n\nLoad back end scripts\n\n\nLoad back end CSS\n\n\nSet the list of directories containing templates\n\n\nDefine image styles\n\n\nDefine custom configuration\n\n\nDefine Web Service scopes\n\n\n\n\nMap routes on actions\n\n\nRoutes are separated into three categories : public, private and Web Service routes.\n\n\nmodule.exports = {\n  routes: {\n    public: {\n      ...\n    },\n    private: {\n      ...\n    },\n    ws: {\n      ...\n    }\n  }\n};\n\n\n\n\nRoute descriptor\n\n\nA route map an HTTP method and a path to an action (JavaScript function).\n\n\nThe route :\n\n\n\"get /logout\" : \"app/server/controllers/authenticationController.logoutAction\"\n\n\n\nCan be interpreted as :\n\n\n\n\nA GET request on /logout will call the function logoutAction exposed by module app/server/controllers/authenticationController.js\n\n\n\n\nThe route :\n\n\n\"post /authenticate\" : \"app/server/controllers/authenticationController.authenticateAction\"\n\n\n\nCan be interpreted as :\n\n\n\n\nA POST request on /authenticate will call the function authenticateAction exposed by module app/server/controllers/authenticationController.js\n\n\n\n\nThe route :\n\n\n\"/login\" : \"app/server/controllers/defaultController.defaultAction\"\n\n\n\nCan be interpreted as :\n\n\n\n\nAll requests on /login (GET, POST, DELETE, PUT) will call the function defaultAction exposed by module app/server/controllers/defaultController.js\n\n\n\n\nExample of valid routes :\n\n\nmodule.exports = {\n  routes: {\n    public: {\n      'get /test': 'adminExampleController.getTestAction',\n      'post /test': 'adminExampleController.postTestAction',\n      'put /test': 'adminExampleController.putTestAction',\n      '/': 'exampleController.invalidAction',\n      '/test': 'invalid action'\n    }\n  }\n};\n\n\n\n\nGroup routes\n\n\nYou can group actions by routes :\n\n\nmodule.exports = {\n  routes: {\n    public: {\n      '*': [\n        'adminExampleController.allFirstAction',\n        'adminExampleController.allSecondAction'\n      ]\n    }\n  }\n};\n\n\n\n\nRoute parameters\n\n\nYou can add parameters using colon character :\n\n\nmodule.exports = {\n  routes: {\n    public: {\n      'DELETE /test/:id': 'adminExampleController.deleteTestAction'\n    }\n  }\n};\n\n\n\n\nCreate entities\n\n\nEntities are elements subject to CRUD (\nC\nreate \nR\nead \nU\npdate \nD\nelete). For exemple, OpenVeo core defines 5 entities :\n\n\n\n\napplications - Web Service client applications\n\n\nusers - Back end users\n\n\nroles - Back end roles\n\n\ngroups - Groups\n\n\ntaxonomies - Taxonomies with associated terms\n\n\n\n\nEach entity will automatically have 3 associated back end permissions : add, update and delete.\n\n\nTo create a new entity you need to create a new EntityController, EntityModel and EntityProvider. You can also use the \nentity generator\n.\n\n\nLet's say we want to create a new entity called \nbook\n.\n\n\nCreate entity provider\n\n\n'use strict';\n\nvar util = require('util');\nvar openVeoAPI = require('@openveo/api');\n\n/**\n * Creates a BookProvider.\n */\nfunction BookProvider(database) {\n\n  // In BookProvider collection \nbooks\n\n  openVeoAPI.EntityProvidercall(this, database, 'book_books');\n}\n\n// BookProvider must extend EntityProvider\nmodule.exports = BookProvider;\nutil.inherits(BookProvider, openVeoAPI.EntityProvider);\n\n\n\n\n\nCreate entity model\n\n\n'use strict';\n\n// Module dependencies\nvar util = require('util');\nvar openVeoAPI = require('@openveo/api');\n\nvar BookProvider = process.requireBook('app/server/providers/BookProvider.js');\n\n/**\n * Creates a BookModel.\n */\nfunction BookModel() {\n  openVeoAPI.EntityModel.call(this, new BookProvider(openVeoAPI.applicationStorage.getDatabase()));\n}\n\nmodule.exports = BookModel;\nutil.inherits(BookModel, openVeoAPI.EntityModel);\n\n\n\n\nCreate entity controller\n\n\n'use strict';\n\nvar util = require('util');\nvar openVeoAPI = require('@openveo/api');\nvar BookModel = process.requireBook('app/server/models/BookModel.js');\nvar EntityController = openVeoAPI.controllers.EntityController;\n\n/**\n * Creates a BookController.\n */\nfunction BookController(database) {\n  EntityController.call(this, BookModel);\n}\n\nmodule.exports = BookController;\nutil.inherits(BookController, EntityController);\n\n\n\n\n\nDeclare entity\n\n\nYou can now declare your entity in \nconf.js\n :\n\n\nmodule.exports = {\n  entities: {\n    books: 'BookController'\n  }\n};\n\n\n\n\nUse the entity\n\n\nNow that you entity \nbook\n is created you can see the 3 new permissions in the back end (add, update and delete). You can also perform CRUD operations on your entity using the following routes :\n\n\n\n\nget /book/books/:id\n - Get a particular book\n\n\nget /book/books\n - Get all books\n\n\npost /book/books/:id\n - Update a particular book\n\n\nput /book/books\n - Add a new book\n\n\ndelete /book/books/:id\n - Delete a book\n\n\n\n\nDefine back end permissions\n\n\nEach role can have n associated permissions. Permissions are described in \nconf.js\n :\n\n\nmodule.exports = {\n  permissions: [\n    ...\n  ]\n};\n\n\n\n\nCreate a permission\n\n\nLet's create new permissions \"sell\" and \"buy\" to sell / buy books.\n\n\nmodule.exports = {\n  permissions: [\n    {\n      id: 'book-sell-book', // Permission id\n      name: 'Sell', // Permission name\n      description: 'Sell books', // Permission description\n      paths: [ // List of paths associated to the permission\n        'get /book/sell*'\n      ]\n    },\n    {\n      id: 'book-buy-book', // Permission id\n      name: 'Buy', // Permission name\n      description: 'Buy books', // Permission description\n      paths: [ // List of paths associated to the permission\n        'get /book/buy*'\n      ]\n    }\n  ]\n};\n\n\n\n\nGroup permissions\n\n\nYou can group permissions to organize the list of permissions in the back end.\n\n\nNb\n : Actually OpenVeo only supports one sub level\n\n\nmodule.exports = {\n  permissions: [\n    {\n      label: 'Books', // Group label\n      permissions: [ // List of permission in the group\n        {\n          id: 'book-sell-book',\n          name: 'Sell',\n          description: 'Sell books',\n          paths: [\n            'get /book/sell*'\n          ]\n        },\n        {\n          id: 'book-buy-book',\n          name: 'Buy',\n          description: 'Buy books',\n          paths: [\n            'get /book/buy*'\n          ]\n        }\n      ]\n    }\n  ]\n};\n\n\n\n\nUse permissions\n\n\nYou can assign your permission to a role through the back end or manipulate the permission using \nback end client\n (AngularJS application).\n\n\nDefine back end menu items\n\n\nBack end menu items are described in \nconf.js\n :\n\n\nmodule.exports = {\n  backOffice: {\n    menu: [\n      ...\n    ]\n  }\n};\n\n\n\n\nAdd a menu item\n\n\nLet's create two new back end menu items.\n\n\nmodule.exports = {\n  backOffice: {\n    menu: [\n      {\n        label: 'Sell books', // Menu item name\n        path: 'book/sell-books', // Menu item path\n        permission: 'book-sell-book' // Menu item associated permission\n      },\n      {\n        label: 'Buy books', // Menu item name\n        path: 'book/buy-books', // Menu item path\n        permission: 'book-buy-book' // Menu item associated permission\n      }\n    ]\n  }\n};\n\n\n\n\nweight\n property helps order menu items, the larger the weight is, the better will be the item position.\n\n\npath\n defines the AngularJS root path (see \nback end client\n)\n\n\npermission\n associates a permission to the menu item, if the connected user doesn't have that permission the item won't be displayed\n\n\nGroup menu items\n\n\nYou can group menu items as sub menu items.\n\n\nNb\n : Actually OpenVeo only supports one sub level of menu items\n\n\nmodule.exports = {\n  backOffice: {\n    menu: [\n      {\n        weight: 100, // Position of the item in the menu\n        label: 'Books', // Name of the menu item\n        subMenu: [ // List of sub menu items\n          {\n            label: 'Sell books', // Menu item name\n            path: 'book/sell-books', // Menu item path\n            permission: 'book-sell-book' // Menu item associated permission\n          },\n          {\n            label: 'Buy books', // Menu item name\n            path: 'book/buy-books', // Menu item path\n            permission: 'book-buy-book' // Menu item associated permission\n          }\n        ]\n      }\n    ]\n  }\n};\n\n\n\n\nBack end scripts\n\n\nThe list of JavaScript files to load for the AngularJS back end application are defined in \nconf.js\n :\n\n\nmodule.exports = {\n  backOffice: {\n    scriptLibFiles: { // List of back end JavaScript files to load first\n      base: [ // List of scripts to load on both development and production environments\n        ...\n      ],\n      dev: [ // List of scripts to load on development environment\n        ...\n      ],\n      prod: [ // List of script to load on production environment\n        ...\n      ]\n    },\n    scriptFiles: { // List of back end JavaScript files to load next\n      dev: [ // List of scripts to load on development environment\n        ...\n      ],\n      prod: [ // List of script to load on production environment\n        ...\n      ]\n    }\n  }\n};\n\n\n\n\nBack end CSS\n\n\nThe list of CSS files to load for the AngularJS back end application are defined in \nconf.js\n :\n\n\nmodule.exports = {\n  backOffice: {\n    cssFiles: [ // List of CSS to load\n      ...\n    ]\n  }\n};\n\n\n\n\nList of directories containing templates\n\n\nOpenVeo uses \nMustache\n as the template engine. Mustache requires directories were to look for potential templates. The list of directories is defined in \nconf.js\n :\n\n\nmodule.exports = {\n  viewsFolders: [ // List of directories holding mustache templates\n    ...\n  ]\n};\n\n\n\n\nDefine image styles\n\n\nYou can define image styles in \nconf.js\n :\n\n\nmodule.exports = {\n  imageProcessing: {\n    imagesFolders: ['example/images'], // List of folders concerned by this style\n    cacheDir: 'example/.thumbs', // Path of the directory containing generated images\n    quality: 50, // Compression level (from 0 to 100)\n    imagesStyle: { // Style to apply\n      'small': 200 // Width (in px) of the image to generate for small style\n    }\n  }\n};\n\n\n\n\nDefault width is 10px if no image style is specified for the directory.\n\nDefault \ncacheDir\n is .thumbs directory at the root of the application.\n\nDefault quality is 90.\n\n\nThen you can call the image with your custom style \nsmall\n\n\nimg src=\nbook/example/images/image1.jpg?thumb=small\n/\n\n\n\n\n\nDefine custom configuration\n\n\nYou can define a custom configuration object in \nconf.js\n :\n\n\nmodule.exports = {\n  custom: {\n    customProperty1: 'customValue1',\n    customProperty2: 2\n  }\n};\n\n\n\n\nNb :\n Custom configuration won't be interpreted but can be retrieved later using OpenVeo API. You can use it to configure your plugin.\n\n\nDefine Web Service scopes\n\n\nYou can define Web Service scopes in \nconf.js\n :\n\n\nmodule.exports = {\n  webServiceScopes: [\n    {\n      id: 'book-scopeId',\n      name: 'Scope name',\n      description: 'Scope description',\n      paths: [\n        'get /book/book/sell/*',\n        'get /book/book/books*'\n      ]\n    }\n  ]\n};\n\n\n\n\nA scope is defined by an id, a name, a description and a list of authorized paths for a Web Service application who has access to this scope.\n\nRoutes like \n/book/book/sell/25\n or \n/book/book/books\n will be available for a Web Service application with the scope \nbook-scopeId\n in the above example.", 
            "title": "conf.js"
        }, 
        {
            "location": "/developers/conf/#introduction", 
            "text": "A consequent part of the development of openveo-core and plugins is made in  conf.js  file at project root.  conf.js  is used to :   Map routes on actions  Create entities  Define back end permissions  Define back end menu items  Load back end scripts  Load back end CSS  Set the list of directories containing templates  Define image styles  Define custom configuration  Define Web Service scopes", 
            "title": "Introduction"
        }, 
        {
            "location": "/developers/conf/#map-routes-on-actions", 
            "text": "Routes are separated into three categories : public, private and Web Service routes.  module.exports = {\n  routes: {\n    public: {\n      ...\n    },\n    private: {\n      ...\n    },\n    ws: {\n      ...\n    }\n  }\n};", 
            "title": "Map routes on actions"
        }, 
        {
            "location": "/developers/conf/#route-descriptor", 
            "text": "A route map an HTTP method and a path to an action (JavaScript function).  The route :  \"get /logout\" : \"app/server/controllers/authenticationController.logoutAction\"  Can be interpreted as :   A GET request on /logout will call the function logoutAction exposed by module app/server/controllers/authenticationController.js   The route :  \"post /authenticate\" : \"app/server/controllers/authenticationController.authenticateAction\"  Can be interpreted as :   A POST request on /authenticate will call the function authenticateAction exposed by module app/server/controllers/authenticationController.js   The route :  \"/login\" : \"app/server/controllers/defaultController.defaultAction\"  Can be interpreted as :   All requests on /login (GET, POST, DELETE, PUT) will call the function defaultAction exposed by module app/server/controllers/defaultController.js   Example of valid routes :  module.exports = {\n  routes: {\n    public: {\n      'get /test': 'adminExampleController.getTestAction',\n      'post /test': 'adminExampleController.postTestAction',\n      'put /test': 'adminExampleController.putTestAction',\n      '/': 'exampleController.invalidAction',\n      '/test': 'invalid action'\n    }\n  }\n};", 
            "title": "Route descriptor"
        }, 
        {
            "location": "/developers/conf/#group-routes", 
            "text": "You can group actions by routes :  module.exports = {\n  routes: {\n    public: {\n      '*': [\n        'adminExampleController.allFirstAction',\n        'adminExampleController.allSecondAction'\n      ]\n    }\n  }\n};", 
            "title": "Group routes"
        }, 
        {
            "location": "/developers/conf/#route-parameters", 
            "text": "You can add parameters using colon character :  module.exports = {\n  routes: {\n    public: {\n      'DELETE /test/:id': 'adminExampleController.deleteTestAction'\n    }\n  }\n};", 
            "title": "Route parameters"
        }, 
        {
            "location": "/developers/conf/#create-entities", 
            "text": "Entities are elements subject to CRUD ( C reate  R ead  U pdate  D elete). For exemple, OpenVeo core defines 5 entities :   applications - Web Service client applications  users - Back end users  roles - Back end roles  groups - Groups  taxonomies - Taxonomies with associated terms   Each entity will automatically have 3 associated back end permissions : add, update and delete.  To create a new entity you need to create a new EntityController, EntityModel and EntityProvider. You can also use the  entity generator .  Let's say we want to create a new entity called  book .", 
            "title": "Create entities"
        }, 
        {
            "location": "/developers/conf/#create-entity-provider", 
            "text": "'use strict';\n\nvar util = require('util');\nvar openVeoAPI = require('@openveo/api');\n\n/**\n * Creates a BookProvider.\n */\nfunction BookProvider(database) {\n\n  // In BookProvider collection  books \n  openVeoAPI.EntityProvidercall(this, database, 'book_books');\n}\n\n// BookProvider must extend EntityProvider\nmodule.exports = BookProvider;\nutil.inherits(BookProvider, openVeoAPI.EntityProvider);", 
            "title": "Create entity provider"
        }, 
        {
            "location": "/developers/conf/#create-entity-model", 
            "text": "'use strict';\n\n// Module dependencies\nvar util = require('util');\nvar openVeoAPI = require('@openveo/api');\n\nvar BookProvider = process.requireBook('app/server/providers/BookProvider.js');\n\n/**\n * Creates a BookModel.\n */\nfunction BookModel() {\n  openVeoAPI.EntityModel.call(this, new BookProvider(openVeoAPI.applicationStorage.getDatabase()));\n}\n\nmodule.exports = BookModel;\nutil.inherits(BookModel, openVeoAPI.EntityModel);", 
            "title": "Create entity model"
        }, 
        {
            "location": "/developers/conf/#create-entity-controller", 
            "text": "'use strict';\n\nvar util = require('util');\nvar openVeoAPI = require('@openveo/api');\nvar BookModel = process.requireBook('app/server/models/BookModel.js');\nvar EntityController = openVeoAPI.controllers.EntityController;\n\n/**\n * Creates a BookController.\n */\nfunction BookController(database) {\n  EntityController.call(this, BookModel);\n}\n\nmodule.exports = BookController;\nutil.inherits(BookController, EntityController);", 
            "title": "Create entity controller"
        }, 
        {
            "location": "/developers/conf/#declare-entity", 
            "text": "You can now declare your entity in  conf.js  :  module.exports = {\n  entities: {\n    books: 'BookController'\n  }\n};", 
            "title": "Declare entity"
        }, 
        {
            "location": "/developers/conf/#use-the-entity", 
            "text": "Now that you entity  book  is created you can see the 3 new permissions in the back end (add, update and delete). You can also perform CRUD operations on your entity using the following routes :   get /book/books/:id  - Get a particular book  get /book/books  - Get all books  post /book/books/:id  - Update a particular book  put /book/books  - Add a new book  delete /book/books/:id  - Delete a book", 
            "title": "Use the entity"
        }, 
        {
            "location": "/developers/conf/#define-back-end-permissions", 
            "text": "Each role can have n associated permissions. Permissions are described in  conf.js  :  module.exports = {\n  permissions: [\n    ...\n  ]\n};", 
            "title": "Define back end permissions"
        }, 
        {
            "location": "/developers/conf/#create-a-permission", 
            "text": "Let's create new permissions \"sell\" and \"buy\" to sell / buy books.  module.exports = {\n  permissions: [\n    {\n      id: 'book-sell-book', // Permission id\n      name: 'Sell', // Permission name\n      description: 'Sell books', // Permission description\n      paths: [ // List of paths associated to the permission\n        'get /book/sell*'\n      ]\n    },\n    {\n      id: 'book-buy-book', // Permission id\n      name: 'Buy', // Permission name\n      description: 'Buy books', // Permission description\n      paths: [ // List of paths associated to the permission\n        'get /book/buy*'\n      ]\n    }\n  ]\n};", 
            "title": "Create a permission"
        }, 
        {
            "location": "/developers/conf/#group-permissions", 
            "text": "You can group permissions to organize the list of permissions in the back end.  Nb  : Actually OpenVeo only supports one sub level  module.exports = {\n  permissions: [\n    {\n      label: 'Books', // Group label\n      permissions: [ // List of permission in the group\n        {\n          id: 'book-sell-book',\n          name: 'Sell',\n          description: 'Sell books',\n          paths: [\n            'get /book/sell*'\n          ]\n        },\n        {\n          id: 'book-buy-book',\n          name: 'Buy',\n          description: 'Buy books',\n          paths: [\n            'get /book/buy*'\n          ]\n        }\n      ]\n    }\n  ]\n};", 
            "title": "Group permissions"
        }, 
        {
            "location": "/developers/conf/#use-permissions", 
            "text": "You can assign your permission to a role through the back end or manipulate the permission using  back end client  (AngularJS application).", 
            "title": "Use permissions"
        }, 
        {
            "location": "/developers/conf/#define-back-end-menu-items", 
            "text": "Back end menu items are described in  conf.js  :  module.exports = {\n  backOffice: {\n    menu: [\n      ...\n    ]\n  }\n};", 
            "title": "Define back end menu items"
        }, 
        {
            "location": "/developers/conf/#add-a-menu-item", 
            "text": "Let's create two new back end menu items.  module.exports = {\n  backOffice: {\n    menu: [\n      {\n        label: 'Sell books', // Menu item name\n        path: 'book/sell-books', // Menu item path\n        permission: 'book-sell-book' // Menu item associated permission\n      },\n      {\n        label: 'Buy books', // Menu item name\n        path: 'book/buy-books', // Menu item path\n        permission: 'book-buy-book' // Menu item associated permission\n      }\n    ]\n  }\n};  weight  property helps order menu items, the larger the weight is, the better will be the item position.  path  defines the AngularJS root path (see  back end client )  permission  associates a permission to the menu item, if the connected user doesn't have that permission the item won't be displayed", 
            "title": "Add a menu item"
        }, 
        {
            "location": "/developers/conf/#group-menu-items", 
            "text": "You can group menu items as sub menu items.  Nb  : Actually OpenVeo only supports one sub level of menu items  module.exports = {\n  backOffice: {\n    menu: [\n      {\n        weight: 100, // Position of the item in the menu\n        label: 'Books', // Name of the menu item\n        subMenu: [ // List of sub menu items\n          {\n            label: 'Sell books', // Menu item name\n            path: 'book/sell-books', // Menu item path\n            permission: 'book-sell-book' // Menu item associated permission\n          },\n          {\n            label: 'Buy books', // Menu item name\n            path: 'book/buy-books', // Menu item path\n            permission: 'book-buy-book' // Menu item associated permission\n          }\n        ]\n      }\n    ]\n  }\n};", 
            "title": "Group menu items"
        }, 
        {
            "location": "/developers/conf/#back-end-scripts", 
            "text": "The list of JavaScript files to load for the AngularJS back end application are defined in  conf.js  :  module.exports = {\n  backOffice: {\n    scriptLibFiles: { // List of back end JavaScript files to load first\n      base: [ // List of scripts to load on both development and production environments\n        ...\n      ],\n      dev: [ // List of scripts to load on development environment\n        ...\n      ],\n      prod: [ // List of script to load on production environment\n        ...\n      ]\n    },\n    scriptFiles: { // List of back end JavaScript files to load next\n      dev: [ // List of scripts to load on development environment\n        ...\n      ],\n      prod: [ // List of script to load on production environment\n        ...\n      ]\n    }\n  }\n};", 
            "title": "Back end scripts"
        }, 
        {
            "location": "/developers/conf/#back-end-css", 
            "text": "The list of CSS files to load for the AngularJS back end application are defined in  conf.js  :  module.exports = {\n  backOffice: {\n    cssFiles: [ // List of CSS to load\n      ...\n    ]\n  }\n};", 
            "title": "Back end CSS"
        }, 
        {
            "location": "/developers/conf/#list-of-directories-containing-templates", 
            "text": "OpenVeo uses  Mustache  as the template engine. Mustache requires directories were to look for potential templates. The list of directories is defined in  conf.js  :  module.exports = {\n  viewsFolders: [ // List of directories holding mustache templates\n    ...\n  ]\n};", 
            "title": "List of directories containing templates"
        }, 
        {
            "location": "/developers/conf/#define-image-styles", 
            "text": "You can define image styles in  conf.js  :  module.exports = {\n  imageProcessing: {\n    imagesFolders: ['example/images'], // List of folders concerned by this style\n    cacheDir: 'example/.thumbs', // Path of the directory containing generated images\n    quality: 50, // Compression level (from 0 to 100)\n    imagesStyle: { // Style to apply\n      'small': 200 // Width (in px) of the image to generate for small style\n    }\n  }\n};  Default width is 10px if no image style is specified for the directory. \nDefault  cacheDir  is .thumbs directory at the root of the application. \nDefault quality is 90.  Then you can call the image with your custom style  small  img src= book/example/images/image1.jpg?thumb=small /", 
            "title": "Define image styles"
        }, 
        {
            "location": "/developers/conf/#define-custom-configuration", 
            "text": "You can define a custom configuration object in  conf.js  :  module.exports = {\n  custom: {\n    customProperty1: 'customValue1',\n    customProperty2: 2\n  }\n};  Nb :  Custom configuration won't be interpreted but can be retrieved later using OpenVeo API. You can use it to configure your plugin.", 
            "title": "Define custom configuration"
        }, 
        {
            "location": "/developers/conf/#define-web-service-scopes", 
            "text": "You can define Web Service scopes in  conf.js  :  module.exports = {\n  webServiceScopes: [\n    {\n      id: 'book-scopeId',\n      name: 'Scope name',\n      description: 'Scope description',\n      paths: [\n        'get /book/book/sell/*',\n        'get /book/book/books*'\n      ]\n    }\n  ]\n};  A scope is defined by an id, a name, a description and a list of authorized paths for a Web Service application who has access to this scope. \nRoutes like  /book/book/sell/25  or  /book/book/books  will be available for a Web Service application with the scope  book-scopeId  in the above example.", 
            "title": "Define Web Service scopes"
        }, 
        {
            "location": "/developers/back-end/", 
            "text": "Introduction\n\n\nOpenVeo back end is an \nAngularJS\n single page application served on \n/be\n.\n\n\nThe back end relies on a couple of libraries :\n\n\n\n\nangular-route\n to perform single page application routing\n\n\nangular-animate\n for CSS animations\n\n\nangular-cookies\n for cookie management\n\n\nangular-i18n\n for AngularJS default translations\n\n\nangular-touch\n to manage gesture\n\n\nangular-bootstrap\n for basic user interface components\n\n\nangular-formly\n to build formulars from a JavaScript literal object\n\n\nangular-ui-tree\n to build an UI tree (not directly used by openveo-core)\n\n\nng-jsonpath\n to search on a JSON object (not directly used by openveo-core)\n\n\nng-tasty\n to present entities in a dynamic paginated table\n\n\n\n\nStructure\n\n\nMain module (\nov\n)\n\n\nThe main AngularJS module of the back end is named \nov\n and is applied to the HTML root element.\n\n\nhtml ng-app=\nov\n ng-controller=\nMainController\n ng-strict-di\n\n\n  \nhead\n\n    \nbase href=\n/be/\n\n  \n/head\n\n\n  ...\n  \ndiv ng-view\n/div\n\n  ...\n\n/html\n\n\n\n\n\nIt has dependencies on all AngularJS libraries and all AngularJS modules described by OpenVeo plugins. It also defines all core routes :\n\n\n\n\n/be/login\n to access the login page\n\n\n/be\n to access the back end home page\n\n\n/be/applications-list\n to access Web service applications page\n\n\n/be/users-list\n to access users page\n\n\n/be/profile\n to access user's profile page\n\n\n/be/roles-list\n to access roles page\n\n\n\n\nNb:\n Available services / filters defined in \nov\n module are described in the \nAPI\n.\n\n\nAlert module (\nov.alert\n)\n\n\nOffers a service to control alerts for the whole application. Alerts are used to display a message to the user.\n\n\nNb:\n Available services defined in \nov.alert\n module are described in the \nAPI\n.\n\n\nAuthentication module (\nov.authentication\n)\n\n\nOffers a service to authenticate / logout or manipulate authenticated user informations. User information are stored locally using the ov.storage module.\n\n\nNb:\n Available services / filters defined in \nov.authentication\n module are described in the \nAPI\n.\n\n\nEntity module (\nov.entity\n)\n\n\nOffers a service to manage (CRUD) OpenVeo entities described in \nconf.js\n.\n\n\nNb:\n Available services defined in \nov.entity\n module are described in the \nAPI\n.\n\n\nI18n module (\nov.i18n\n)\n\n\nDefines a service to control back end internationalization and a \ntranslate\n filter to help translate ids from a dictionary.\n\n\nNb:\n Available services / filters defined in \nov.i18n\n module are described in the \nAPI\n.\n\n\nStorage module (\nov.storage\n)\n\n\nOffers a service to manipulate the local storage.\n\n\nNb:\n Available services defined in \nov.storage\n module are described in the \nAPI\n.\n\n\nTableForm module (\nov.tableForm\n)\n\n\nOffers a turnkey solution to build formulars and tasty tables.\n\n\nFormulars are the same as described in \nangular-formly\n.\n\n\nDatatables are a little different from the original \nng-tasty\n datable as actions can be assigned to a row and information about the row can be edited in place. Datatables needs an associated entity to work.\n\n\nAdd a new form\n\n\nFormulars are massively based on \nangular-formly\n.\nTo add a new formular, you have to place the generic formular partial in your HTML code and describe the expected form in your controller.\n\n\nInclude formular partial in your HTML.\n\n\nng-include src=\n'views/elements/form.html'\n/ng-include\n\n\n\n\n\nDescribes the formular in your controller.\n\n\n\n// List of books\n$scope.books = [{\n  \nisbn\n: \n50\n,\n  \nname\n: \nJourney to the Center of the Earth\n\n}];\n\n// Create a scope property \naddFormContainer\n\n$scope.addFormContainer = {};\n\n// Create a property \nmodel\n on \naddFormContainer\n, this is were formly will\n// stores form results\n// This is the model of the form\n$scope.addFormContainer.model = {};\n\n// Describe fields just like in formly documentation\n$scope.addFormContainer.fields = [\n  {\n    key: 'name',\n    type: 'horizontalInput',\n    templateOptions: {\n      label: 'Label of the name field',\n      required: true,\n      description: 'Description of the name field'\n    }\n  },\n  {\n    key: 'books',\n    type: 'horizontalMultiCheckbox',\n    templateOptions: {\n      label: 'Books',\n      required: false,\n      options: $scope.books,\n      valueProperty: 'isbn',\n      labelProperty: 'name',\n      description: 'List of books'\n    },\n    expressionProperties: {\n      'templateOptions.disabled': '!model.name' // disabled when book name is blank\n    }\n  }\n];\n\n// Add formular submit function\n$scope.addFormContainer.onSubmit = function(model) {\n\n  // Return Angularjs promises with its own success or error callback\n  // Code to save the formular\n  // Generic error or success callback are already chained and executed by the form container\n  // in order to display the right message to user and update the form\n  return promise;\n};\n\n\n\n\nAdd a new datatable\n\n\nTables are massively based on \nng-tasty\n.\nTo add a new datatable, you have to place the generic datatable partial in your HTML code and describe the datatable expected behavior in your controller.\n\n\nInclude datatable partial in your HTML.\n\n\nng-include src=\n'views/elements/dataTable.html'\n/ng-include\n\n\n\n\n\nDescribes the datatable in your controller.\n\n\nFor the example, assume that you need to display a collection of \nbook\n entity.\n\n\n{\n  \nisbn\n: \n50\n,\n  \nname\n: \nJourney to the Center of the Earth\n,\n  \ndescription\n : \nThe story begins in May 1863, in the Lidenbrock house in Hamburg, Germany, with Professor Lidenbrock\n\n}\n\n\n\n\n\n\nInitialize tableContainer Object:\n\n\n\n\n// Create tableContainer Object used by DataTable controller\n$scope.tableContainer = {};\n\n// Initialize the entity type to enable DataTable controller to retrieve the right entity\n$scope.tableContainer.entityType = 'book';\n\n\n\n\n\n\nInitialize search filters\n\n\n\n\n$scope.tableContainer.filterBy = [\n  {\n    key: 'name',  // properties to filter on\n    value: '',    // initial value\n    label: 'Label of the name search filter'\n  }\n];\n\n\n\n\nFilters default type is text. Filter type can be set by adding \ntype\n properties to filter object.\n\n\n{\n  key: 'author',\n  type: 'select',\n  options : selectOptions,\n  value: '',\n  label: 'Label of the author search filter',\n  filterWithChildren: true  // default:false; if true table filter will select with the selectId AND additionnal id set in the \nchildren\n key of the selected options\n},\n{\n  key: 'date',\n  type: 'date',\n  value: '',\n  label : 'Label of the date search filter'\n}\n\n\n\n\nWhere \nselectOptions\n need to be describe in this format:\n\n\n[\n  {\n    \nvalue\n: 'id',\n    \nname\n: 'title',\n    \nchildren\n : 'id1,id2,id3'\n  },\n  ...\n]\n\n\n\n\n\n\nInitialize DataTable headers\n\n\n\n\n// Each column need to display a property,\n// Automatically, a sort filter is enable on each column except 'Action' column\n$scope.tableContainer.header = [{\n  key: 'name',                      // property co display and sort in column\n  name: 'Label of the name column',\n  class: ['col-xs-12 col-sm-11']    // css class to add on header cell\n},\n{\n  key: 'action',\n  name: 'Label for action button' ,\n  class: [' hidden-xs col-sm-1'],\n}];\n\n\n\n\nHeader object 'action' is \nREQUIRED\n and not bind any sort filter.\n\n\nHeaders default type is text. Filter type can be set by adding \ntype\n properties to filter object.\nDefault \ndate\n (timestamp) and \ntext\n value are enabled.\nBut you can add any type if you make your own custom cell rendrer (see after)\n\n\n{\n  key: 'date',\n  name: 'Label of the date column',\n  type: 'date'\n},\n{\n  key: 'author',\n  name: 'Label of the author column',\n  type: 'author'\n}\n\n\n\n\n\n\nAdd a custom cell template renderer according to column key and row value\n\n\n\n\n//Usefull to add HTML value, or filtered value\n//if not defined, can print date and text\n//if defined, add custom cells renderer to date and text\n$scope.tableContainer.cellTheme = '/path/to/cells/template.html';\n\n\n\n\nFor example (assuming that \nentities\n is the header type to render, an \nrow[entities.key]\n, the value to display)\n\n\nspan ng-if=\nentities.type \n entities.type == 'type1' \n row[entities.key]\n{{row[entities.key] | filterType1}}\n/span\n\n\nspan ng-if=\nentities.type \n entities.type == 'type2'\n ng-bind-html=\nrow[entities.key] | filterType2\n/span\n\n\n\n\n\n \nBE CAREFUL ABOUT PERFORMANCES WHEN USING YOUR OWN FILTERS\n \n\n\n\n\nInitialize action enable on each row\n\n\n\n\n$scope.tableContainer.actions = [{\n  label: 'Label of action',\n\n  // Enable a Popup confirmation before action execution, default: false if not defined\n  warningPopup: true,\n\n  // Condition to enable the action in the dropdown button action\n  condition: function(row) {\n    return $scope.rights.delete \n !row.locked \n !row.saving;\n  },\n\n  // Function to execute when the action is executed by button\n  callback: function(row, reload) {\n    // row is the book object on which the action is executed\n    action(row.id);\n    // call reload if dataTable need to be reloaded\n    reload();\n  },\n\n  // Function to execute when the action is executed by select checkbox action\n  // If not defined, this action can't be seen in checkbox actions\n  global: function(selected, reload) {\n    // selected is the list of selected entity id when global action is executed\n    // exemple: [12345,12346,12347,12348,12349]\n    actions(selected, reload);\n  }\n}];\n\n\n\n\n\n\nInitialize initial sort\n\n\n\n\n$scope.tableContainer.init = {\n  sortBy: 'name',  // initial sort key, default: first header column key if not defined\n  sortOrder: 'dsc' // initial sort order, default: 'asc' if not defined\n};\n\n\n\n\n\n\nDisplay checkbox global selection\n\n\n\n\n//default true if not defined;\n$scope.tableContainer.showSelectAll = true;\n\n\n\n\nYou can reload a display table manually from other controller by injecting the \nTableReloadEventService\n and calling\n\n\ntableReloadEventService.broadcast();\n\n\n\n\nDatatable dependency: edit a row\n\n\nDataTable is dependent of an edit form. This form specify what information user can access and/or modify.\nAll properties described in the \nAdd a new form\n section can be used to describe the form.\nMain differencies are that the form need to be initialized by the open row (the model is not exposed), and that form fields MUST be editable types.\n\n\n\n\nInitialize editFormContainer object\n\n\n\n\n// Create a scope property \neditFormContainer\n\n$scope.addFormContainer = {};\n\n// Create a property \nmodel\n on \neditFormContainer\n, this is were formly will\n// stores form results\n// This is the model of the form\n$scope.editFormContainer.model = {};\n\n// Initialize the entity type to retrieve before the row is updated\n// to always update the latest value in database.\n$scope.editFormContainer.entityType = 'book';\n\n// Add formular submit function\n$scope.editFormContainer.onSubmit = function(model) {\n    return promises;\n};\n\n// Define if a row can be toggled or not\n$scope.editFormContainer.conditionToggleDetail = function(row) {\n  return row.state !== 0;\n};\n// Define if a row can be edit or not\n$scope.editFormContainer.conditionEditDetail = function(row) {\n  return !row.locked;\n};\n\n\n\n\n\n\nSet Fields\n\n\n\n\n// Describe fields just like in formly documentation with OpenVeo editable fields types\n$scope.editFormContainer.fields = {\n  // the key to be used in the model values\n  key: 'name',\n  type: 'horizontalEditableInput',\n  templateOptions: {\n    label: 'label for name input',\n    required: true\n  }\n};\n\n\n\n\n\n\nSet Fields dynamically\n\n\n\n\n// Function call when the form is displayed\n// Usefull to add fields dynamically according to the open row,\n// or retrieve information relative to the row\n$scope.editFormContainer.init = function(row) {\n  if(row.state == SHOW.PROPERTY){\n    var newField = {\n      key: 'property',\n      type: 'horizontalEditableInput',\n      model: row.property,\n      templateOptions: {\n        label: 'Label of the new property field'\n      }\n    };\n    $scope.editFormContainer.fields.push(newField);\n  }\n}\n\n\n\n\nField types\n\n\nOpenVeo defines the following list of formly fields.\n\n\n\n\n\n\n\n\nField type\n\n\nDescription\n\n\nSpecific options\n\n\n\n\n\n\n\n\n\n\ntags\n\n\nDisplay an input text to add a list of tags\n\n\n-\n\n\n\n\n\n\nemptyrow\n\n\nDisplay a fake field with a static message\n\n\nmessage\n the message to display\n\n\n\n\n\n\novMultiCheckBox\n\n\nSame as the \"multiCheckbox\" type defined by \nangular-formly-templates-bootstrap\n\n\noptions\n the list of checkboxes description objects with a property for the name of the checkbox and a property for the value of the checkbox ; \nvalueProperty\n to define the property to use to get the checkbox value (default is \"value\") ; \nlabelProperty\n to define the property to use to get the checkbox label (default is \"name\")\n\n\n\n\n\n\nhorizontalInput\n\n\nSame as \"input\" with horizontalBootstrapLabel and bootstrapHasError wrappers\n\n\nSame as \"input\"\n\n\n\n\n\n\nhorizontalSelect\n\n\nSame as \"select\" with horizontalBootstrapLabel and bootstrapHasError wrappers\n\n\nSame as \"select\"\n\n\n\n\n\n\nhorizontalMultiCheckbox\n\n\nSame as \"ovMultiCheckBox\" with horizontalBootstrapLabel and bootstrapHasError wrappers\n\n\nSame as \"ovMultiCheckBox\"\n\n\n\n\n\n\nhorizontalTags\n\n\nSame as \"tags\" with horizontalBootstrapLabel and bootstrapHasError wrappers\n\n\nSame as \"tags\"\n\n\n\n\n\n\n\n\nNb: All field types defined in \nangular-formly-templates-bootstrap\n are also available.\n\n\nEditable field types\n\n\nAn editable field type is capable of displaying the field or its literal representation depending on \"showForm\" property of formState object.\nIf \"showForm\" is set to true, the field is displayed, if set to false, the literal representation of the field is displayed.\n\n\nOpenVeo defines the following list of editable formly fields.\n\n\n\n\n\n\n\n\nField type\n\n\nDescription\n\n\nSpecific options\n\n\n\n\n\n\n\n\n\n\neditableTags\n\n\nMake field type \"tags\" editable\n\n\n-\n\n\n\n\n\n\neditableInput\n\n\nMake field type \"input\" editable\n\n\nSame as \"input\"\n\n\n\n\n\n\neditableSelect\n\n\nMake field type \"select\" editable\n\n\nSame as \"select\"\n\n\n\n\n\n\neditableTags\n\n\nMake field type \"tags\" editable\n\n\nSame as \"tags\"\n\n\n\n\n\n\novEditableMultiCheckBox\n\n\nMake field type \"ovMultiCheckBox\" editable\n\n\nSame as \"ovMultiCheckBox\"\n\n\n\n\n\n\nhorizontalEditableInput\n\n\nSame as \"editableInput\" with horizontalBootstrapLabel and bootstrapHasError wrappers\n\n\nSame as \"editableInput\"\n\n\n\n\n\n\nhorizontalEditableSelect\n\n\nSame as \"editableSelect\" with horizontalBootstrapLabel and bootstrapHasError wrappers\n\n\nSame as \"editableSelect\"\n\n\n\n\n\n\nhorizontalEditableMultiCheckbox\n\n\nSame as \"ovEditableMultiCheckBox\" with horizontalBootstrapLabel and bootstrapHasError wrappers\n\n\nSame as \"ovEditableMultiCheckBox\"\n\n\n\n\n\n\nhorizontalEditableTags\n\n\nSame as \"editableTags\" with horizontalBootstrapLabel and bootstrapHasError wrappers\n\n\nSame as \"editableTags\"\n\n\n\n\n\n\n\n\nField wrappers\n\n\nOpenVeo defines the following list of editable formly wrappers.\n\n\n\n\n\n\n\n\nWrapper name\n\n\nDescription\n\n\nSpecific options\n\n\n\n\n\n\n\n\n\n\ncollapse\n\n\nCollapse / Uncollapse a formly field\n\n\nlabelCollapse\n the label of the collapsible element\n\n\n\n\n\n\nhorizontalBootstrapLabel\n\n\nPut a label in front of a field\n\n\nlabel\n the label ; \nrequired\n a boolean to indicates if a \"*\" character must follow the label\n\n\n\n\n\n\nhorizontalBootstrapLabelOnly\n\n\nSame as \"horizontalBootstrapLabel\" but without wrapping the field\n\n\nSame as \"horizontalBootstrapLabel\"\n\n\n\n\n\n\neditableWrapper\n\n\nDisplay the field or its literal representation depending on \"showForm\" property of formState object. This is the wrapper used by all editable fields\n\n\n-\n\n\n\n\n\n\n\n\nNb: All wrappers defined in \nangular-formly-templates-bootstrap\n are also available.", 
            "title": "Back end AngularJS"
        }, 
        {
            "location": "/developers/back-end/#introduction", 
            "text": "OpenVeo back end is an  AngularJS  single page application served on  /be .  The back end relies on a couple of libraries :   angular-route  to perform single page application routing  angular-animate  for CSS animations  angular-cookies  for cookie management  angular-i18n  for AngularJS default translations  angular-touch  to manage gesture  angular-bootstrap  for basic user interface components  angular-formly  to build formulars from a JavaScript literal object  angular-ui-tree  to build an UI tree (not directly used by openveo-core)  ng-jsonpath  to search on a JSON object (not directly used by openveo-core)  ng-tasty  to present entities in a dynamic paginated table", 
            "title": "Introduction"
        }, 
        {
            "location": "/developers/back-end/#structure", 
            "text": "", 
            "title": "Structure"
        }, 
        {
            "location": "/developers/back-end/#main-module-ov", 
            "text": "The main AngularJS module of the back end is named  ov  and is applied to the HTML root element.  html ng-app= ov  ng-controller= MainController  ng-strict-di \n\n   head \n     base href= /be/ \n   /head \n\n  ...\n   div ng-view /div \n  ... /html   It has dependencies on all AngularJS libraries and all AngularJS modules described by OpenVeo plugins. It also defines all core routes :   /be/login  to access the login page  /be  to access the back end home page  /be/applications-list  to access Web service applications page  /be/users-list  to access users page  /be/profile  to access user's profile page  /be/roles-list  to access roles page   Nb:  Available services / filters defined in  ov  module are described in the  API .", 
            "title": "Main module (ov)"
        }, 
        {
            "location": "/developers/back-end/#alert-module-ovalert", 
            "text": "Offers a service to control alerts for the whole application. Alerts are used to display a message to the user.  Nb:  Available services defined in  ov.alert  module are described in the  API .", 
            "title": "Alert module (ov.alert)"
        }, 
        {
            "location": "/developers/back-end/#authentication-module-ovauthentication", 
            "text": "Offers a service to authenticate / logout or manipulate authenticated user informations. User information are stored locally using the ov.storage module.  Nb:  Available services / filters defined in  ov.authentication  module are described in the  API .", 
            "title": "Authentication module (ov.authentication)"
        }, 
        {
            "location": "/developers/back-end/#entity-module-oventity", 
            "text": "Offers a service to manage (CRUD) OpenVeo entities described in  conf.js .  Nb:  Available services defined in  ov.entity  module are described in the  API .", 
            "title": "Entity module (ov.entity)"
        }, 
        {
            "location": "/developers/back-end/#i18n-module-ovi18n", 
            "text": "Defines a service to control back end internationalization and a  translate  filter to help translate ids from a dictionary.  Nb:  Available services / filters defined in  ov.i18n  module are described in the  API .", 
            "title": "I18n module (ov.i18n)"
        }, 
        {
            "location": "/developers/back-end/#storage-module-ovstorage", 
            "text": "Offers a service to manipulate the local storage.  Nb:  Available services defined in  ov.storage  module are described in the  API .", 
            "title": "Storage module (ov.storage)"
        }, 
        {
            "location": "/developers/back-end/#tableform-module-ovtableform", 
            "text": "Offers a turnkey solution to build formulars and tasty tables.  Formulars are the same as described in  angular-formly .  Datatables are a little different from the original  ng-tasty  datable as actions can be assigned to a row and information about the row can be edited in place. Datatables needs an associated entity to work.", 
            "title": "TableForm module (ov.tableForm)"
        }, 
        {
            "location": "/developers/back-end/#add-a-new-form", 
            "text": "Formulars are massively based on  angular-formly .\nTo add a new formular, you have to place the generic formular partial in your HTML code and describe the expected form in your controller.  Include formular partial in your HTML.  ng-include src= 'views/elements/form.html' /ng-include   Describes the formular in your controller.  \n// List of books\n$scope.books = [{\n   isbn :  50 ,\n   name :  Journey to the Center of the Earth \n}];\n\n// Create a scope property  addFormContainer \n$scope.addFormContainer = {};\n\n// Create a property  model  on  addFormContainer , this is were formly will\n// stores form results\n// This is the model of the form\n$scope.addFormContainer.model = {};\n\n// Describe fields just like in formly documentation\n$scope.addFormContainer.fields = [\n  {\n    key: 'name',\n    type: 'horizontalInput',\n    templateOptions: {\n      label: 'Label of the name field',\n      required: true,\n      description: 'Description of the name field'\n    }\n  },\n  {\n    key: 'books',\n    type: 'horizontalMultiCheckbox',\n    templateOptions: {\n      label: 'Books',\n      required: false,\n      options: $scope.books,\n      valueProperty: 'isbn',\n      labelProperty: 'name',\n      description: 'List of books'\n    },\n    expressionProperties: {\n      'templateOptions.disabled': '!model.name' // disabled when book name is blank\n    }\n  }\n];\n\n// Add formular submit function\n$scope.addFormContainer.onSubmit = function(model) {\n\n  // Return Angularjs promises with its own success or error callback\n  // Code to save the formular\n  // Generic error or success callback are already chained and executed by the form container\n  // in order to display the right message to user and update the form\n  return promise;\n};", 
            "title": "Add a new form"
        }, 
        {
            "location": "/developers/back-end/#add-a-new-datatable", 
            "text": "Tables are massively based on  ng-tasty .\nTo add a new datatable, you have to place the generic datatable partial in your HTML code and describe the datatable expected behavior in your controller.  Include datatable partial in your HTML.  ng-include src= 'views/elements/dataTable.html' /ng-include   Describes the datatable in your controller.  For the example, assume that you need to display a collection of  book  entity.  {\n   isbn :  50 ,\n   name :  Journey to the Center of the Earth ,\n   description  :  The story begins in May 1863, in the Lidenbrock house in Hamburg, Germany, with Professor Lidenbrock \n}   Initialize tableContainer Object:   // Create tableContainer Object used by DataTable controller\n$scope.tableContainer = {};\n\n// Initialize the entity type to enable DataTable controller to retrieve the right entity\n$scope.tableContainer.entityType = 'book';   Initialize search filters   $scope.tableContainer.filterBy = [\n  {\n    key: 'name',  // properties to filter on\n    value: '',    // initial value\n    label: 'Label of the name search filter'\n  }\n];  Filters default type is text. Filter type can be set by adding  type  properties to filter object.  {\n  key: 'author',\n  type: 'select',\n  options : selectOptions,\n  value: '',\n  label: 'Label of the author search filter',\n  filterWithChildren: true  // default:false; if true table filter will select with the selectId AND additionnal id set in the  children  key of the selected options\n},\n{\n  key: 'date',\n  type: 'date',\n  value: '',\n  label : 'Label of the date search filter'\n}  Where  selectOptions  need to be describe in this format:  [\n  {\n     value : 'id',\n     name : 'title',\n     children  : 'id1,id2,id3'\n  },\n  ...\n]   Initialize DataTable headers   // Each column need to display a property,\n// Automatically, a sort filter is enable on each column except 'Action' column\n$scope.tableContainer.header = [{\n  key: 'name',                      // property co display and sort in column\n  name: 'Label of the name column',\n  class: ['col-xs-12 col-sm-11']    // css class to add on header cell\n},\n{\n  key: 'action',\n  name: 'Label for action button' ,\n  class: [' hidden-xs col-sm-1'],\n}];  Header object 'action' is  REQUIRED  and not bind any sort filter.  Headers default type is text. Filter type can be set by adding  type  properties to filter object.\nDefault  date  (timestamp) and  text  value are enabled.\nBut you can add any type if you make your own custom cell rendrer (see after)  {\n  key: 'date',\n  name: 'Label of the date column',\n  type: 'date'\n},\n{\n  key: 'author',\n  name: 'Label of the author column',\n  type: 'author'\n}   Add a custom cell template renderer according to column key and row value   //Usefull to add HTML value, or filtered value\n//if not defined, can print date and text\n//if defined, add custom cells renderer to date and text\n$scope.tableContainer.cellTheme = '/path/to/cells/template.html';  For example (assuming that  entities  is the header type to render, an  row[entities.key] , the value to display)  span ng-if= entities.type   entities.type == 'type1'   row[entities.key] {{row[entities.key] | filterType1}} /span  span ng-if= entities.type   entities.type == 'type2'  ng-bind-html= row[entities.key] | filterType2 /span     BE CAREFUL ABOUT PERFORMANCES WHEN USING YOUR OWN FILTERS     Initialize action enable on each row   $scope.tableContainer.actions = [{\n  label: 'Label of action',\n\n  // Enable a Popup confirmation before action execution, default: false if not defined\n  warningPopup: true,\n\n  // Condition to enable the action in the dropdown button action\n  condition: function(row) {\n    return $scope.rights.delete   !row.locked   !row.saving;\n  },\n\n  // Function to execute when the action is executed by button\n  callback: function(row, reload) {\n    // row is the book object on which the action is executed\n    action(row.id);\n    // call reload if dataTable need to be reloaded\n    reload();\n  },\n\n  // Function to execute when the action is executed by select checkbox action\n  // If not defined, this action can't be seen in checkbox actions\n  global: function(selected, reload) {\n    // selected is the list of selected entity id when global action is executed\n    // exemple: [12345,12346,12347,12348,12349]\n    actions(selected, reload);\n  }\n}];   Initialize initial sort   $scope.tableContainer.init = {\n  sortBy: 'name',  // initial sort key, default: first header column key if not defined\n  sortOrder: 'dsc' // initial sort order, default: 'asc' if not defined\n};   Display checkbox global selection   //default true if not defined;\n$scope.tableContainer.showSelectAll = true;  You can reload a display table manually from other controller by injecting the  TableReloadEventService  and calling  tableReloadEventService.broadcast();", 
            "title": "Add a new datatable"
        }, 
        {
            "location": "/developers/back-end/#datatable-dependency-edit-a-row", 
            "text": "DataTable is dependent of an edit form. This form specify what information user can access and/or modify.\nAll properties described in the  Add a new form  section can be used to describe the form.\nMain differencies are that the form need to be initialized by the open row (the model is not exposed), and that form fields MUST be editable types.   Initialize editFormContainer object   // Create a scope property  editFormContainer \n$scope.addFormContainer = {};\n\n// Create a property  model  on  editFormContainer , this is were formly will\n// stores form results\n// This is the model of the form\n$scope.editFormContainer.model = {};\n\n// Initialize the entity type to retrieve before the row is updated\n// to always update the latest value in database.\n$scope.editFormContainer.entityType = 'book';\n\n// Add formular submit function\n$scope.editFormContainer.onSubmit = function(model) {\n    return promises;\n};\n\n// Define if a row can be toggled or not\n$scope.editFormContainer.conditionToggleDetail = function(row) {\n  return row.state !== 0;\n};\n// Define if a row can be edit or not\n$scope.editFormContainer.conditionEditDetail = function(row) {\n  return !row.locked;\n};   Set Fields   // Describe fields just like in formly documentation with OpenVeo editable fields types\n$scope.editFormContainer.fields = {\n  // the key to be used in the model values\n  key: 'name',\n  type: 'horizontalEditableInput',\n  templateOptions: {\n    label: 'label for name input',\n    required: true\n  }\n};   Set Fields dynamically   // Function call when the form is displayed\n// Usefull to add fields dynamically according to the open row,\n// or retrieve information relative to the row\n$scope.editFormContainer.init = function(row) {\n  if(row.state == SHOW.PROPERTY){\n    var newField = {\n      key: 'property',\n      type: 'horizontalEditableInput',\n      model: row.property,\n      templateOptions: {\n        label: 'Label of the new property field'\n      }\n    };\n    $scope.editFormContainer.fields.push(newField);\n  }\n}", 
            "title": "Datatable dependency: edit a row"
        }, 
        {
            "location": "/developers/back-end/#field-types", 
            "text": "OpenVeo defines the following list of formly fields.     Field type  Description  Specific options      tags  Display an input text to add a list of tags  -    emptyrow  Display a fake field with a static message  message  the message to display    ovMultiCheckBox  Same as the \"multiCheckbox\" type defined by  angular-formly-templates-bootstrap  options  the list of checkboxes description objects with a property for the name of the checkbox and a property for the value of the checkbox ;  valueProperty  to define the property to use to get the checkbox value (default is \"value\") ;  labelProperty  to define the property to use to get the checkbox label (default is \"name\")    horizontalInput  Same as \"input\" with horizontalBootstrapLabel and bootstrapHasError wrappers  Same as \"input\"    horizontalSelect  Same as \"select\" with horizontalBootstrapLabel and bootstrapHasError wrappers  Same as \"select\"    horizontalMultiCheckbox  Same as \"ovMultiCheckBox\" with horizontalBootstrapLabel and bootstrapHasError wrappers  Same as \"ovMultiCheckBox\"    horizontalTags  Same as \"tags\" with horizontalBootstrapLabel and bootstrapHasError wrappers  Same as \"tags\"     Nb: All field types defined in  angular-formly-templates-bootstrap  are also available.", 
            "title": "Field types"
        }, 
        {
            "location": "/developers/back-end/#editable-field-types", 
            "text": "An editable field type is capable of displaying the field or its literal representation depending on \"showForm\" property of formState object.\nIf \"showForm\" is set to true, the field is displayed, if set to false, the literal representation of the field is displayed.  OpenVeo defines the following list of editable formly fields.     Field type  Description  Specific options      editableTags  Make field type \"tags\" editable  -    editableInput  Make field type \"input\" editable  Same as \"input\"    editableSelect  Make field type \"select\" editable  Same as \"select\"    editableTags  Make field type \"tags\" editable  Same as \"tags\"    ovEditableMultiCheckBox  Make field type \"ovMultiCheckBox\" editable  Same as \"ovMultiCheckBox\"    horizontalEditableInput  Same as \"editableInput\" with horizontalBootstrapLabel and bootstrapHasError wrappers  Same as \"editableInput\"    horizontalEditableSelect  Same as \"editableSelect\" with horizontalBootstrapLabel and bootstrapHasError wrappers  Same as \"editableSelect\"    horizontalEditableMultiCheckbox  Same as \"ovEditableMultiCheckBox\" with horizontalBootstrapLabel and bootstrapHasError wrappers  Same as \"ovEditableMultiCheckBox\"    horizontalEditableTags  Same as \"editableTags\" with horizontalBootstrapLabel and bootstrapHasError wrappers  Same as \"editableTags\"", 
            "title": "Editable field types"
        }, 
        {
            "location": "/developers/back-end/#field-wrappers", 
            "text": "OpenVeo defines the following list of editable formly wrappers.     Wrapper name  Description  Specific options      collapse  Collapse / Uncollapse a formly field  labelCollapse  the label of the collapsible element    horizontalBootstrapLabel  Put a label in front of a field  label  the label ;  required  a boolean to indicates if a \"*\" character must follow the label    horizontalBootstrapLabelOnly  Same as \"horizontalBootstrapLabel\" but without wrapping the field  Same as \"horizontalBootstrapLabel\"    editableWrapper  Display the field or its literal representation depending on \"showForm\" property of formState object. This is the wrapper used by all editable fields  -     Nb: All wrappers defined in  angular-formly-templates-bootstrap  are also available.", 
            "title": "Field wrappers"
        }, 
        {
            "location": "/developers/write-plugin/", 
            "text": "Introduction\n\n\nAs OpenVeo server starts, all plugins found in \nnode_modules/@openveo/\n will be loaded. Each plugin can add routes and add its own pages in the back end.\n\n\nIf your using \nopenveo-plugin-generator\n, most of files detailed after will be automatically created and ready to use in OpenVeo.\n\n\nLet's pretend we want to create a plugin called \nbook\n to manage a list of books.\n\n\nCreate plugin's directory\n\n\nThe first thing we need is a plugin's directory, create a directory \nbook\n under \nnode_modules/@openveo/\n (\nnode_modules/@openveo/book\n).\n\n\nCreate plugin's main file\n\n\nA plugin must have a class which extends \nPlugin\n class.\n\n\nCreate a file \nBookPlugin.js\n at the root of your plugin directory.\n\n\n'use strict';\n\n// Module dependencies\nvar util = require('util');\nvar express = require('express');\nvar openVeoAPI = require('@openveo/api');\n\n/**\n * Creates a BookPlugin.\n */\nfunction BookPlugin() {\n\n  // Creates a public router\n  // It will be automatically mounted on /book/ by the core\n  this.router = express.Router();\n\n  // Creates a private router\n  // All routes associated to the private router require a back end authentication\n  // It will be automatically mounted on /be/book/ by the core\n  this.privateRouter = express.Router();\n\n  // Creates a Web Service router\n  // All routes associated to the Web Service router will be part of the Web Service\n  // It will be automatically mounter on /book/ by the core (but on another server)\n  this.webServiceRouter = express.Router();\n\n}\n\n// Expose BookPlugin\nmodule.exports = BookPlugin;\n\n// Extends Plugin\nutil.inherits(BookPlugin, openVeoAPI.Plugin);\n\n/**\n * Optional \ninit\n method automatically called by core application\n * after plugin is loaded and before it is started.\n */\nBookPlugin.prototype.init = function(callback) {\n  console.log('Book plugin initialization');\n  callback();\n};\n\n/**\n * Optional \nstart\n method automatically called by core application\n * after plugin is loaded and initialized.\n */\nBookPlugin.prototype.start = function(callback) {\n  console.log('Book plugin starting');\n  callback();\n};\n\n\n\n\nIf you don't want to expose public routes, private routes or Web Service routes, just remove the corresponding router.\n\n\nCreate plugin's entry point\n\n\nA plugin must have an entry point. Either the one described in your \npackage.json\n file (if you have one) or an \nindex.js\n file. This is the file loaded by the core.\n\n\nCreate a file \nindex.js\n at the root of your plugin directory.\n\n\n'use strict';\n\n// Module dependencies\nvar path = require('path');\n\n// Set module root directory\nprocess.rootBook = __dirname;\n\n// Define a new method on process object to be able to require\n// a module with a path relative to plugin's root directory\nprocess.requireBook = function(filePath) {\n  return require(path.join(process.requireBook, filePath));\n};\n\n// Expose the BookPlugin\nmodule.exports = process.requireBook('app/server/BookPlugin.js');\n\n\n\n\nAs the plugin will be loaded by OpenVeo core, root of the OpenVeo application will be the root of OpenVeo core and not the root of your plugin. To avoid confusion and collision between the core and your plugin, define a property process.root\nPLUGIN_NAME\n to have a reference to the root of your plugin.\n\n\nA best practice is to also add a require\nPLUGIN_NAME\n function to load your JavaScript files with paths relative to the root of your plugin.\n\nFor example, if you want to load a file \ndir/test.js\n from file \ndir/subDir/index.js\n instead of writing :\n\n\nvar test = require('../test.js');\n\n\n\n\nYou can write :\n\n\nvar test = process.requireBook('dir/subDir/test.js');\n\n\n\n\nLike that moving the file \nindex.js\n won't break your code.\n\n\nAt this point you have a functional plugin, but it does nothing. When launching the server, the plugin is loaded by the core and message '\nBook plugin loaded\n' is displayed in the console.\n\n\nCreate routes\n\n\nTo add features to our Book plugin we need to define routes.\n\n\nCreate a file \nconf.js\n at the root of your plugin directory. Take a look at \nconf.js documentation\n for more details about \nconf.js\n file.\n\n\nFor our example, let's create a public route, a private route and a Web Service route.\n\n\nmodule.exports = {\n  routes: {\n    public: {\n      'get /:id': 'controllers/BookController.displayBookAction'\n    },\n    private: {\n      'get /read/:id': 'controllers/BookController.readBookAction'\n    },\n    ws: {\n      'get /read/:id': 'controllers/BookController.readBookAction'\n    }\n  }\n};\n\n\n\n\nAs a reminder :\n\n\n\n\npublic routes will be mounted on \n/book/\n\n\nprivate routes will be mounted on \n/be/book/\n\n\nWeb Service routes will be mounted on \n/book/\n (but on another server)\n\n\n\n\nCreate the controller\n\n\n3 routes have been defined in \nconf.js\n :\n\n\n\n\n/book/:id\n pointing to \ncontrollers/BookController.js\n, method \ndisplayBookAction\n\n\n/book/read/:id\n pointing to \ncontrollers/BookController.js\n, method \nreadBookAction\n\n\n/book/read/:id\n pointing to \ncontrollers/BookController.js\n, method \nreadBookAction\n\n\n\n\nCreate a file \ncontrollers/BookController.js\n with \ndisplayBookAction\n and \nreadBookAction\n methods :\n\n\n'use strict';\n\nvar util = require('util');\nvar openVeoAPI = require('@openveo/api');\nvar Controller = openVeoAPI.controllers.Controller;\n\nfunction BookController() {\n  Controller.call(this);\n}\n\nmodule.exports = BookController;\nutil.inherits(BookController, Controller);\n\n/**\n * Displays a book.\n */\nDefaultController.prototype.displayBookAction = function(request, response, next) {\n  var bookId = request.params.id;\n\n  // Retrieve books\n  var books = {\n    '1': {\n      title: 'Journey to the center of the earth',\n      summary: 'The story begins in May 1863, in the Lidenbrock house in Hamburg, Germany, with Professor Lidenbrock rushing home to peruse his latest purchase, an original runic manuscript of an Icelandic saga written by Snorri Sturluson (\nHeimskringla\n; the chronicle of the Norwegian kings who ruled over Iceland).'\n    }\n  };\n\n  // Display template book.html using Mustache template\n  response.render('book', books[bookId]);\n};\n\n/**\n * Reads book content and return it as a JSON object.\n */\nDefaultController.prototype.readBookAction = function(request, response, next) {\n  var bookId = request.params.id;\n\n  // Retrieve books\n  var books = {\n    '1': {\n      content: 'Journey to the center of the earth'\n    }\n  };\n\n  response.send({\n    book: books[bookId].content\n  });\n\n};\n\n\n\n\nYou can now restart your server, connect to the back end (/be/login) and navigate to \n/be/book/read/1\n to read the book.\n\n\nCreate a template\n\n\nThe public route \n/book/:id\n call the \ndisplayBookAction\n function on the \nBookController\n.\n\n\ndisplayBookAction\n needs a template \nbook.html\n to display information about the book.\n\n\nCreate a file \nviews/book.html\n :\n\n\n!DOCTYPE html\n\n\nhtml\n\n  \nbody\n\n    \ndiv\n\n      \nh1\n{{title}}\n/h1\n\n      \np\n{{summary}}\n/p\n\n    \n/div\n\n  \n/body\n\n\n/html\n\n\n\n\n\nAnd add the \nviews\n directory to the list of directories containing Mustache templates (in \nconf.js\n file) :\n\n\nmodule.exports = {\n  viewsFolders: [\n    'views'\n  ]\n};\n\n\n\n\nYou can now restart your server and navigate to \n/book/1\n to have information about the book.\n\n\nAdd directory of resources\n\n\nYou can add an \nassets\n directory at the root of your plugin, all files inside that directory will be served as they are. You can put here images, front JavaScript files, CSS files and so on. The core will mount this directory on \n/book/\n, thus to access image \nassets/test.jpg\n you have to call \n/book/test.jpg\n.\n\n\nAdd page to the back end\n\n\nPlugins can add pages to the back end menu.\n\n\nConfigure page\n\n\nAs described in \nconf.js documentation\n you can add a page to the back end :\n\n\nmodule.exports = {\n  backOffice: {\n    menu: [\n      {\n        label: 'Books',\n        subMenu: [\n          {\n            label: 'Configuration',\n            path: 'config'\n          }\n        ]\n      }\n    ]\n  }\n};\n\n\n\n\nCreate AngularJS module\n\n\nAs OpenVeo back end is written in AngularJS, we must create an AngularJS module to add pages to the back end.\n\n\nCreate a file \nassets/be/js/BookApp.js\n :\n\n\n(function(angular) {\n\n  'use strict';\n\n  // Module name must respect the form ov.PLUGIN_DIRECTORY_NAME\n  var app = angular.module(\nov.book\n, []);\n\n  /**\n   * Configures the ov.book application by adding new routes.\n   */\n  app.config(['$routeProvider', function($routeProvider) {\n\n    // Add route /book/config\n    $routeProvider.when('/book/config', {\n      templateUrl: '/book/be/views/config.html',\n      controller: 'BookController',\n      title: 'Book configuration'\n    });\n\n  }]);\n\n  /**\n   * Defines the book controller for the configuration page.\n   */\n  function BookController($scope) {\n\n  }\n\n  app.controller('BookController', BookController);\n  BookController.$inject = ['$scope'];\n\n})(angular);\n\n\n\n\nCreate the partial file \nassets/be/views/config.html\n :\n\n\np\nConfiguration template\n/p\n\n\n\n\n\nAnd add \nBookApp.js\n to the list of scripts to load with the back end (\nin conf.js\n) :\n\n\nmodule.exports = {\n  backOffice: {\n    scriptFiles: {\n      dev: [\n        '/book/be/js/BookApp.js'\n      ]\n    }\n  }\n};\n\n\n\n\nTranslate your back end pages\n\n\nYou can translate your back end pages using the back end dictionary called \nadmin-back-office\n. Core will search for an \ni18n\n directory to look for dictionaries.\n\n\nCreate an \ni18n\n directory with french and english dictionaries for the back end :\n\n\ni18n/admin-back-office-en.json\n :\n\n\n{\n  \nBOOK\n : {\n    \nCONFIGURATION\n : \nConfiguration template\n\n  }\n}\n\n\n\n\ni18n/admin-back-office-fr.json\n :\n\n\n{\n  \nBOOK\n : {\n    \nCONFIGURATION\n : \nTemplate de configuration\n\n  }\n}\n\n\n\n\nYou can now translate your \nconfig.html\n file :\n\n\np\n{{'BOOK.CONFIGURATION' | translate}}\n/p\n\n\n\n\n\nNb :\n For more information on internationalization please refer to the \ni18n documentation\n.", 
            "title": "Write a plugin"
        }, 
        {
            "location": "/developers/write-plugin/#introduction", 
            "text": "As OpenVeo server starts, all plugins found in  node_modules/@openveo/  will be loaded. Each plugin can add routes and add its own pages in the back end.  If your using  openveo-plugin-generator , most of files detailed after will be automatically created and ready to use in OpenVeo.  Let's pretend we want to create a plugin called  book  to manage a list of books.", 
            "title": "Introduction"
        }, 
        {
            "location": "/developers/write-plugin/#create-plugins-directory", 
            "text": "The first thing we need is a plugin's directory, create a directory  book  under  node_modules/@openveo/  ( node_modules/@openveo/book ).", 
            "title": "Create plugin's directory"
        }, 
        {
            "location": "/developers/write-plugin/#create-plugins-main-file", 
            "text": "A plugin must have a class which extends  Plugin  class.  Create a file  BookPlugin.js  at the root of your plugin directory.  'use strict';\n\n// Module dependencies\nvar util = require('util');\nvar express = require('express');\nvar openVeoAPI = require('@openveo/api');\n\n/**\n * Creates a BookPlugin.\n */\nfunction BookPlugin() {\n\n  // Creates a public router\n  // It will be automatically mounted on /book/ by the core\n  this.router = express.Router();\n\n  // Creates a private router\n  // All routes associated to the private router require a back end authentication\n  // It will be automatically mounted on /be/book/ by the core\n  this.privateRouter = express.Router();\n\n  // Creates a Web Service router\n  // All routes associated to the Web Service router will be part of the Web Service\n  // It will be automatically mounter on /book/ by the core (but on another server)\n  this.webServiceRouter = express.Router();\n\n}\n\n// Expose BookPlugin\nmodule.exports = BookPlugin;\n\n// Extends Plugin\nutil.inherits(BookPlugin, openVeoAPI.Plugin);\n\n/**\n * Optional  init  method automatically called by core application\n * after plugin is loaded and before it is started.\n */\nBookPlugin.prototype.init = function(callback) {\n  console.log('Book plugin initialization');\n  callback();\n};\n\n/**\n * Optional  start  method automatically called by core application\n * after plugin is loaded and initialized.\n */\nBookPlugin.prototype.start = function(callback) {\n  console.log('Book plugin starting');\n  callback();\n};  If you don't want to expose public routes, private routes or Web Service routes, just remove the corresponding router.", 
            "title": "Create plugin's main file"
        }, 
        {
            "location": "/developers/write-plugin/#create-plugins-entry-point", 
            "text": "A plugin must have an entry point. Either the one described in your  package.json  file (if you have one) or an  index.js  file. This is the file loaded by the core.  Create a file  index.js  at the root of your plugin directory.  'use strict';\n\n// Module dependencies\nvar path = require('path');\n\n// Set module root directory\nprocess.rootBook = __dirname;\n\n// Define a new method on process object to be able to require\n// a module with a path relative to plugin's root directory\nprocess.requireBook = function(filePath) {\n  return require(path.join(process.requireBook, filePath));\n};\n\n// Expose the BookPlugin\nmodule.exports = process.requireBook('app/server/BookPlugin.js');  As the plugin will be loaded by OpenVeo core, root of the OpenVeo application will be the root of OpenVeo core and not the root of your plugin. To avoid confusion and collision between the core and your plugin, define a property process.root PLUGIN_NAME  to have a reference to the root of your plugin.  A best practice is to also add a require PLUGIN_NAME  function to load your JavaScript files with paths relative to the root of your plugin. \nFor example, if you want to load a file  dir/test.js  from file  dir/subDir/index.js  instead of writing :  var test = require('../test.js');  You can write :  var test = process.requireBook('dir/subDir/test.js');  Like that moving the file  index.js  won't break your code.  At this point you have a functional plugin, but it does nothing. When launching the server, the plugin is loaded by the core and message ' Book plugin loaded ' is displayed in the console.", 
            "title": "Create plugin's entry point"
        }, 
        {
            "location": "/developers/write-plugin/#create-routes", 
            "text": "To add features to our Book plugin we need to define routes.  Create a file  conf.js  at the root of your plugin directory. Take a look at  conf.js documentation  for more details about  conf.js  file.  For our example, let's create a public route, a private route and a Web Service route.  module.exports = {\n  routes: {\n    public: {\n      'get /:id': 'controllers/BookController.displayBookAction'\n    },\n    private: {\n      'get /read/:id': 'controllers/BookController.readBookAction'\n    },\n    ws: {\n      'get /read/:id': 'controllers/BookController.readBookAction'\n    }\n  }\n};  As a reminder :   public routes will be mounted on  /book/  private routes will be mounted on  /be/book/  Web Service routes will be mounted on  /book/  (but on another server)", 
            "title": "Create routes"
        }, 
        {
            "location": "/developers/write-plugin/#create-the-controller", 
            "text": "3 routes have been defined in  conf.js  :   /book/:id  pointing to  controllers/BookController.js , method  displayBookAction  /book/read/:id  pointing to  controllers/BookController.js , method  readBookAction  /book/read/:id  pointing to  controllers/BookController.js , method  readBookAction   Create a file  controllers/BookController.js  with  displayBookAction  and  readBookAction  methods :  'use strict';\n\nvar util = require('util');\nvar openVeoAPI = require('@openveo/api');\nvar Controller = openVeoAPI.controllers.Controller;\n\nfunction BookController() {\n  Controller.call(this);\n}\n\nmodule.exports = BookController;\nutil.inherits(BookController, Controller);\n\n/**\n * Displays a book.\n */\nDefaultController.prototype.displayBookAction = function(request, response, next) {\n  var bookId = request.params.id;\n\n  // Retrieve books\n  var books = {\n    '1': {\n      title: 'Journey to the center of the earth',\n      summary: 'The story begins in May 1863, in the Lidenbrock house in Hamburg, Germany, with Professor Lidenbrock rushing home to peruse his latest purchase, an original runic manuscript of an Icelandic saga written by Snorri Sturluson ( Heimskringla ; the chronicle of the Norwegian kings who ruled over Iceland).'\n    }\n  };\n\n  // Display template book.html using Mustache template\n  response.render('book', books[bookId]);\n};\n\n/**\n * Reads book content and return it as a JSON object.\n */\nDefaultController.prototype.readBookAction = function(request, response, next) {\n  var bookId = request.params.id;\n\n  // Retrieve books\n  var books = {\n    '1': {\n      content: 'Journey to the center of the earth'\n    }\n  };\n\n  response.send({\n    book: books[bookId].content\n  });\n\n};  You can now restart your server, connect to the back end (/be/login) and navigate to  /be/book/read/1  to read the book.", 
            "title": "Create the controller"
        }, 
        {
            "location": "/developers/write-plugin/#create-a-template", 
            "text": "The public route  /book/:id  call the  displayBookAction  function on the  BookController .  displayBookAction  needs a template  book.html  to display information about the book.  Create a file  views/book.html  :  !DOCTYPE html  html \n   body \n     div \n       h1 {{title}} /h1 \n       p {{summary}} /p \n     /div \n   /body  /html   And add the  views  directory to the list of directories containing Mustache templates (in  conf.js  file) :  module.exports = {\n  viewsFolders: [\n    'views'\n  ]\n};  You can now restart your server and navigate to  /book/1  to have information about the book.", 
            "title": "Create a template"
        }, 
        {
            "location": "/developers/write-plugin/#add-directory-of-resources", 
            "text": "You can add an  assets  directory at the root of your plugin, all files inside that directory will be served as they are. You can put here images, front JavaScript files, CSS files and so on. The core will mount this directory on  /book/ , thus to access image  assets/test.jpg  you have to call  /book/test.jpg .", 
            "title": "Add directory of resources"
        }, 
        {
            "location": "/developers/write-plugin/#add-page-to-the-back-end", 
            "text": "Plugins can add pages to the back end menu.", 
            "title": "Add page to the back end"
        }, 
        {
            "location": "/developers/write-plugin/#configure-page", 
            "text": "As described in  conf.js documentation  you can add a page to the back end :  module.exports = {\n  backOffice: {\n    menu: [\n      {\n        label: 'Books',\n        subMenu: [\n          {\n            label: 'Configuration',\n            path: 'config'\n          }\n        ]\n      }\n    ]\n  }\n};", 
            "title": "Configure page"
        }, 
        {
            "location": "/developers/write-plugin/#create-angularjs-module", 
            "text": "As OpenVeo back end is written in AngularJS, we must create an AngularJS module to add pages to the back end.  Create a file  assets/be/js/BookApp.js  :  (function(angular) {\n\n  'use strict';\n\n  // Module name must respect the form ov.PLUGIN_DIRECTORY_NAME\n  var app = angular.module( ov.book , []);\n\n  /**\n   * Configures the ov.book application by adding new routes.\n   */\n  app.config(['$routeProvider', function($routeProvider) {\n\n    // Add route /book/config\n    $routeProvider.when('/book/config', {\n      templateUrl: '/book/be/views/config.html',\n      controller: 'BookController',\n      title: 'Book configuration'\n    });\n\n  }]);\n\n  /**\n   * Defines the book controller for the configuration page.\n   */\n  function BookController($scope) {\n\n  }\n\n  app.controller('BookController', BookController);\n  BookController.$inject = ['$scope'];\n\n})(angular);  Create the partial file  assets/be/views/config.html  :  p Configuration template /p   And add  BookApp.js  to the list of scripts to load with the back end ( in conf.js ) :  module.exports = {\n  backOffice: {\n    scriptFiles: {\n      dev: [\n        '/book/be/js/BookApp.js'\n      ]\n    }\n  }\n};", 
            "title": "Create AngularJS module"
        }, 
        {
            "location": "/developers/write-plugin/#translate-your-back-end-pages", 
            "text": "You can translate your back end pages using the back end dictionary called  admin-back-office . Core will search for an  i18n  directory to look for dictionaries.  Create an  i18n  directory with french and english dictionaries for the back end :  i18n/admin-back-office-en.json  :  {\n   BOOK  : {\n     CONFIGURATION  :  Configuration template \n  }\n}  i18n/admin-back-office-fr.json  :  {\n   BOOK  : {\n     CONFIGURATION  :  Template de configuration \n  }\n}  You can now translate your  config.html  file :  p {{'BOOK.CONFIGURATION' | translate}} /p   Nb :  For more information on internationalization please refer to the  i18n documentation .", 
            "title": "Translate your back end pages"
        }, 
        {
            "location": "/developers/compilation/", 
            "text": "Introduction\n\n\nOpenVeo back end is written using AngularJS and SASS / Compass. SASS files need to be compiled to generate the CSS and JavaScript files can be minified and aggregated for better performance.\n\n\nCompiling SASS files\n\n\nYou can compile the back end SASS files using the following command :\n\n\ngrunt compass:dist\n\n\n\nOr you can watch SASS files changes using the following command :\n\n\ngrunt\n\n\n\nCompiling JavaScript files\n\n\nYou'll probably want to compile AngularJS files, in production, for better performance. You can do it using :\n\n\ngrunt prod", 
            "title": "CSS / SASS / JS compilation"
        }, 
        {
            "location": "/developers/compilation/#introduction", 
            "text": "OpenVeo back end is written using AngularJS and SASS / Compass. SASS files need to be compiled to generate the CSS and JavaScript files can be minified and aggregated for better performance.", 
            "title": "Introduction"
        }, 
        {
            "location": "/developers/compilation/#compiling-sass-files", 
            "text": "You can compile the back end SASS files using the following command :  grunt compass:dist  Or you can watch SASS files changes using the following command :  grunt", 
            "title": "Compiling SASS files"
        }, 
        {
            "location": "/developers/compilation/#compiling-javascript-files", 
            "text": "You'll probably want to compile AngularJS files, in production, for better performance. You can do it using :  grunt prod", 
            "title": "Compiling JavaScript files"
        }, 
        {
            "location": "/developers/template-engine/", 
            "text": "OpenVeo uses \nMustache\n as the template engine. You have to declare your directory containing template files before using a mustache template file. You can do it in \nconf.js\n file.\n\n\nThen you can call the template using \nrender express function\n in your controller action.", 
            "title": "Template engine"
        }, 
        {
            "location": "/developers/logger/", 
            "text": "Introduction\n\n\nAll server logs are performed by module \nWinston\n.\n\n\nUse OpenVeo logger\n\n\nBy default OpenVeo core creates one logger named \nopenveo\n. You can get this logger using the following code :\n\n\nprocess.logger.silly('Silly log');\nprocess.logger.debug('Debug log');\nprocess.logger.verbose('Verbose log');\nprocess.logger.info('Info log');\nprocess.logger.warn('Warn log');\nprocess.logger.error('Error log');", 
            "title": "Logger"
        }, 
        {
            "location": "/developers/logger/#introduction", 
            "text": "All server logs are performed by module  Winston .", 
            "title": "Introduction"
        }, 
        {
            "location": "/developers/logger/#use-openveo-logger", 
            "text": "By default OpenVeo core creates one logger named  openveo . You can get this logger using the following code :  process.logger.silly('Silly log');\nprocess.logger.debug('Debug log');\nprocess.logger.verbose('Verbose log');\nprocess.logger.info('Info log');\nprocess.logger.warn('Warn log');\nprocess.logger.error('Error log');", 
            "title": "Use OpenVeo logger"
        }, 
        {
            "location": "/developers/i18n/", 
            "text": "Introduction\n\n\nOpenVeo translations are grouped by dictionaries (JSON files in i18n directory). Actually the server is capable of returning a dictionary by its name and language. Nothing more. The OpenVeo back end is translated on the client side application (AngularJS).\n\n\nDictionaries\n\n\nDictionaries are all stored in \ni18n directory\n. Dictionary file name is composed of the name of the dictionary followed by the language code :\n\n\n[DICTIONARY_NAME]\n-\n[LANGUAGE_CODE]\n.json\n\n\nWith :\n\n\n\n\n[DICTIONARY_NAME]\n the name of the dictionary\n\n\n[LANGUAGE_CODE]\n the language code\n\n\n\n\ne.g.\n \nmy-dictionary\n-\nen_ca\n.json (will contain translations of dictionary \"my-dictionary\" for Canadian english)\n\n\ne.g.\n \nmy-dictionary\n-\nfr\n.json (will contain translations of dictionary \"my-dictionary\" for French)\n\n\nIf the dictionary must be accessible only by users authenticated to the back end, you must add the prefix : \nadmin-\n.\n\n\ne.g.\n \nadmin-\nmy-dictionary-en_ca.json\n\n\nGet a public dictionary\n\n\nFrom client side, you can request a dictionary using \n/getDictionary/:dictionary/:code\n\n\ne.g.\n \n/getDictionary/my-dictionary/en_ca\n\n\nGet a back end dictionary\n\n\nFrom client side, you can request a back end dictionary (requiring an authenticated user) using \n/be/getDictionary/:dictionary/:code\n\n\ne.g.\n \n/be/getDictionary/my-dictionary/en_ca\n\n\nNb :\n Your dictionary file will be \nadmin-my-dictionary-en_ca.json\n\n\nYou can use the back end AngularJS API (module \nov.i18n\n) to help you manipulate dictionaries.\n\n\nAdd translations to existing dictionary\n\n\nBy default, openveo core defines several dictionaries, one of these dictionaries is the admin-back-office dictionary. You may want to add translations to this dictionary to avoid requesting 2 dictionaries. For example if we want, in our \nbook\n plugin, to add the following translations :\n\n\ni18n/admin-back-office-en.json\n\n\n{\n  \nMENU\n : {\n    \nMY_ITEM\n : \nMy menu item\n\n  }\n}\n\n\n\n\nCalling \n/be/getDictionary/back-office/en\n will return :\n\n\n{\n  \nCORE\n : {\n    \nMENU\n : {\n      \nWEB_SERVICE\n : \nWeb Service\n,\n      \nRIGHTS\n : \nRights\n,\n      \nROLES\n : \nRoles\n,\n      \nUSERS\n : \nUsers\n,\n      \nGROUPS\n : \nGroups\n,\n      \nAPPLICATIONS\n : \nApplications\n,\n      \nDASHBOARD\n : \nDashboard\n,\n      \nPROFILES\n  : \nProfile\n,\n      \nLANGUAGE\n : \nLanguage\n,\n      \nLOGOUT\n : \nLogout\n\n    }\n    [...]\n  },\n  \nBOOK\n : {\n    \nMENU\n : {\n      \nMY_ITEM\n : \nMy menu item\n\n    }\n  }\n}\n\n\n\n\nNb :\n You can see that you got both yours and core translations. Not that core translations are wrapped into a \"CORE\" property while your translations are wrapped into a \"BOOK\" property.", 
            "title": "I18N and I10N"
        }, 
        {
            "location": "/developers/i18n/#introduction", 
            "text": "OpenVeo translations are grouped by dictionaries (JSON files in i18n directory). Actually the server is capable of returning a dictionary by its name and language. Nothing more. The OpenVeo back end is translated on the client side application (AngularJS).", 
            "title": "Introduction"
        }, 
        {
            "location": "/developers/i18n/#dictionaries", 
            "text": "Dictionaries are all stored in  i18n directory . Dictionary file name is composed of the name of the dictionary followed by the language code :  [DICTIONARY_NAME] - [LANGUAGE_CODE] .json  With :   [DICTIONARY_NAME]  the name of the dictionary  [LANGUAGE_CODE]  the language code   e.g.   my-dictionary - en_ca .json (will contain translations of dictionary \"my-dictionary\" for Canadian english)  e.g.   my-dictionary - fr .json (will contain translations of dictionary \"my-dictionary\" for French)  If the dictionary must be accessible only by users authenticated to the back end, you must add the prefix :  admin- .  e.g.   admin- my-dictionary-en_ca.json", 
            "title": "Dictionaries"
        }, 
        {
            "location": "/developers/i18n/#get-a-public-dictionary", 
            "text": "From client side, you can request a dictionary using  /getDictionary/:dictionary/:code  e.g.   /getDictionary/my-dictionary/en_ca", 
            "title": "Get a public dictionary"
        }, 
        {
            "location": "/developers/i18n/#get-a-back-end-dictionary", 
            "text": "From client side, you can request a back end dictionary (requiring an authenticated user) using  /be/getDictionary/:dictionary/:code  e.g.   /be/getDictionary/my-dictionary/en_ca  Nb :  Your dictionary file will be  admin-my-dictionary-en_ca.json  You can use the back end AngularJS API (module  ov.i18n ) to help you manipulate dictionaries.", 
            "title": "Get a back end dictionary"
        }, 
        {
            "location": "/developers/i18n/#add-translations-to-existing-dictionary", 
            "text": "By default, openveo core defines several dictionaries, one of these dictionaries is the admin-back-office dictionary. You may want to add translations to this dictionary to avoid requesting 2 dictionaries. For example if we want, in our  book  plugin, to add the following translations :  i18n/admin-back-office-en.json  {\n   MENU  : {\n     MY_ITEM  :  My menu item \n  }\n}  Calling  /be/getDictionary/back-office/en  will return :  {\n   CORE  : {\n     MENU  : {\n       WEB_SERVICE  :  Web Service ,\n       RIGHTS  :  Rights ,\n       ROLES  :  Roles ,\n       USERS  :  Users ,\n       GROUPS  :  Groups ,\n       APPLICATIONS  :  Applications ,\n       DASHBOARD  :  Dashboard ,\n       PROFILES   :  Profile ,\n       LANGUAGE  :  Language ,\n       LOGOUT  :  Logout \n    }\n    [...]\n  },\n   BOOK  : {\n     MENU  : {\n       MY_ITEM  :  My menu item \n    }\n  }\n}  Nb :  You can see that you got both yours and core translations. Not that core translations are wrapped into a \"CORE\" property while your translations are wrapped into a \"BOOK\" property.", 
            "title": "Add translations to existing dictionary"
        }, 
        {
            "location": "/developers/coding-standards/", 
            "text": "OpenVeo uses Node.js coding standards. \nESLint\n is used to validate coding rules. You can launch a code verification using the following command :\n\n\ngrunt eslint\n\n\n\nNb :\n Both Node.js and AngularJS parts of OpenVeo must respect the same coding standards", 
            "title": "Coding standards"
        }, 
        {
            "location": "/developers/unit-tests/", 
            "text": "Node.js unit tests\n\n\nServer side unit tests are performed using \nMocha\n and \nChai\n. You can launch server unit tests with the following command :\n\n\ngrunt mochaTest\n\n\n\nAngularJS unit tests\n\n\nClient side unit tests are performed using \nKarma\n. You can launch client unit tests with the following command :\n\n\ngrunt karma", 
            "title": "Unit tests"
        }, 
        {
            "location": "/developers/unit-tests/#nodejs-unit-tests", 
            "text": "Server side unit tests are performed using  Mocha  and  Chai . You can launch server unit tests with the following command :  grunt mochaTest", 
            "title": "Node.js unit tests"
        }, 
        {
            "location": "/developers/unit-tests/#angularjs-unit-tests", 
            "text": "Client side unit tests are performed using  Karma . You can launch client unit tests with the following command :  grunt karma", 
            "title": "AngularJS unit tests"
        }, 
        {
            "location": "/developers/end-to-end-tests/", 
            "text": "Introduction\n\n\nEnd to end tests are performed using \nProtractor\n and run from \nOpenVeo core\n.\n\n\nYou first have to install and configure tests as described in core documentation.\n\n\nWrite tests\n\n\nAll end to end tests are located in \ntests/client/e2eTests/\n. Suites are described in \ntests/client/protractorSuites.json\n. And the list of datas to create before launching tests are available in \ntests/client/e2eTests/database/data.json\n\n\nLaunch plugin end to end tests\n\n\n# Launch all plugin end to end tests on chrome\ngrunt test-e2e --capabilities=\"{\\\"browserName\\\": \\\"chrome\\\"}\" --directConnect=true --suite=\"plugin\"\n\n# Launch all plugin end to end tests on firefox\ngrunt test-e2e --capabilities=\"{\\\"browserName\\\": \\\"firefox\\\"}\" --directConnect=true --suite=\"plugin\"", 
            "title": "End to end tests"
        }, 
        {
            "location": "/developers/end-to-end-tests/#introduction", 
            "text": "End to end tests are performed using  Protractor  and run from  OpenVeo core .  You first have to install and configure tests as described in core documentation.", 
            "title": "Introduction"
        }, 
        {
            "location": "/developers/end-to-end-tests/#write-tests", 
            "text": "All end to end tests are located in  tests/client/e2eTests/ . Suites are described in  tests/client/protractorSuites.json . And the list of datas to create before launching tests are available in  tests/client/e2eTests/database/data.json", 
            "title": "Write tests"
        }, 
        {
            "location": "/developers/end-to-end-tests/#launch-plugin-end-to-end-tests", 
            "text": "# Launch all plugin end to end tests on chrome\ngrunt test-e2e --capabilities=\"{\\\"browserName\\\": \\\"chrome\\\"}\" --directConnect=true --suite=\"plugin\"\n\n# Launch all plugin end to end tests on firefox\ngrunt test-e2e --capabilities=\"{\\\"browserName\\\": \\\"firefox\\\"}\" --directConnect=true --suite=\"plugin\"", 
            "title": "Launch plugin end to end tests"
        }, 
        {
            "location": "/api/", 
            "text": "Backend AngularJS API\n\n\nThe \nBackend API\n helps you write backend pages for OpenVeo.", 
            "title": "API"
        }, 
        {
            "location": "/api/#backend-angularjs-api", 
            "text": "The  Backend API  helps you write backend pages for OpenVeo.", 
            "title": "Backend AngularJS API"
        }
    ]
}